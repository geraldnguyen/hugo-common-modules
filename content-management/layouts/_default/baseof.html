<!DOCTYPE html>
<html lang="{{ .Site.LanguageCode }}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ if .Title }}{{ .Title }} - {{ end }}{{ .Site.Title }}</title>
    <meta name="description" content="{{ if .Description }}{{ .Description }}{{ else }}{{ .Site.Params.description }}{{ end }}">

    <!-- Site favicon: uses the SVG logo in static/ -->
    <link rel="icon" href="{{ "logo.svg" | relURL }}" type="image/svg+xml">
    <!-- Optional PNG fallback for older browsers: place a 32x32 png at static/favicon-32.png and uncomment the line below -->
    <!-- <link rel="icon" href="{{ "favicon-32.png" | relURL }}" sizes="32x32" type="image/png"> -->
    <!-- Apple touch icon (iOS) - recommended 180x180 PNG at static/apple-touch-icon.png -->
    <!-- Place a PNG at static/apple-touch-icon.png and uncomment the line below to enable -->
    <!-- <link rel="apple-touch-icon" sizes="180x180" href="{{ "apple-touch-icon.png" | relURL }}"> -->
    <!-- Windows tile (mstile) - recommended 150x150 PNG at static/mstile-150x150.png -->
    <!-- Add these meta tags and place files at the given paths to enable Windows tile support -->
    <!--
    <meta name="msapplication-TileColor" content="#ffd54a">
    <meta name="msapplication-TileImage" content="{{ "mstile-150x150.png" | relURL }}">
    -->

    <!-- Open Graph / Facebook -->
    {{ partial "opengraph.html" . }}

    <!-- Google google_analytics -->
    {{ partial "google_analytics.html" . }}

    <!-- Google AdSense -->
    {{ partial "google_adsense.html" . }}
    
    <!-- Fonts -->
    {{ partial "google_font.html" . }}

    <!-- Head verification tags (Pinterest, etc.) -->
    {{ partial "html_head_verify.html" . }}
    
    <!-- CSS -->
    <link rel="stylesheet" href="{{ "css/base.css" | absURL }}">
    <link rel="stylesheet" href="{{ "css/style.css" | absURL }}">

    <style>
    /* Dropdown submenu: hidden by default, shown on hover */
    .nav-menu { position: relative; }
    .nav-item { position: relative; display: inline-block; }
    .nav-item.has-children > .nav-submenu {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        background: #fff;
        min-width: 12rem;
        box-shadow: 0 6px 18px rgba(0,0,0,0.08);
        border-radius: 6px;
        padding: 0.4rem 0.2rem;
        z-index: 1000;
    }
    /* Show submenu on hover (desktop-only: larger screens & hover-capable devices) */
    @media (hover: hover) and (min-width: 769px) {
        .nav-item.has-children:hover > .nav-submenu {
            display: block;
        }
    }
    .nav-submenu .nav-sublink {
        display: block;
        padding: 0.45rem 1rem;
        color: inherit;
        text-decoration: none;
        white-space: nowrap;
    }
    .nav-submenu .nav-sublink:hover {
        background: #f6f9ff;
    }
    /* Keep base layout unchanged on small screens - mobile can use the existing toggle */
    @media (max-width: 768px) {
        .nav-item { display: block; }
        .nav-item.has-children > .nav-submenu { position: static; display: none; }
        .nav-item.has-children.open > .nav-submenu { display: block; }
    }
    </style>

    <style>
    /* Refresh nav menu controls */
    .refresh-nav-menu { display: inline-block; vertical-align: middle; margin-left: 1rem; }
    .refresh-nav-menu .refresh-controls { display:flex; align-items:center; gap:0.5rem; margin-bottom:0.25rem; }
    .refresh-nav-menu .auto-refresh-label { display:flex; align-items:center; gap:0.3rem; font-size:0.9rem; color:var(--muted,#333); }
    .refresh-nav-menu .auto-refresh-toggle { width:1.1rem; height:1.1rem; }
    .refresh-nav-menu .force-refresh { background:transparent; border:1px solid rgba(0,0,0,0.06); padding:0.2rem 0.45rem; border-radius:6px; cursor:pointer; font-size:1rem; }
    .refresh-nav-menu .dynamic-items { display:inline-block; }
    .refresh-nav-menu .nav-item { margin-right:0.4rem; }
    @media (max-width:768px) {
        .refresh-nav-menu { display:block; margin:0.5rem 0 0; }
        .refresh-nav-menu .refresh-controls { margin-bottom:0.5rem; }
    }
    </style>

    {{ partial "html_head.html" . }}


</head>
<body>
    
    <header class="site-header">
        <nav class="navbar">
            <div class="nav-container">
                <div class="nav-brand">
                    {{ partial "nav-social.html" . }}
                    
                    <a href="{{ .Site.BaseURL }}" class="nav-brand">
                        <h1>{{ .Site.Title }}</h1>
                    </a>
                </div>

                <nav class="nav-menu">
                    <!-- 
                    DESIGN REFERENCE:
                    <div class="refresh-nav-menu">
                        <todo: auto refresh toggle>
                        <todo: force refresh icon>
                        <todo: default menu items>
                            {{- range .Site.Menus.top }}
                                {{- $page := $ -}}
                                {{- partial "menu-item.html" (dict "Item" . "Page" $page "MenuName" "main") -}}
                            {{- end }}
                        </todo:>
                        <todo: refresh menu script>
                            - site param: menu length e.g. 4
                            - site param: refresh interval e.g. 15 mins (default: 5 minutes)
                            - mode: "random"
                            - candidates: a dictionary of items to choose from:
                                + The keys can be: taxonomies, terms, pages
                                + The value can be:
                                    * "self": link to the key itself
                                    * "children": link to a random item under the key
                                    * "both": both self and children
                            - Candidate info: candidate's `permalink` in JSON format e.g. `/tags/index.json`
                            - Fetch all candidates (self/children/both), pick random N items (N = menu length param), and render them as menu items. 
                            - Cache the selected items for the refresh interval duration.
                            - If no candidates found, fallback to default menu items.

                        </todo:>
                    </div> 
                    -->

                    <div class="refresh-nav-menu" data-menu-length="{{ with .Site.Params.menuRefresh.length }}{{ . }}{{ else }}4{{ end }}" data-refresh-interval-min="{{ with .Site.Params.menuRefresh.interval }}{{ . }}{{ else }}5{{ end }}" data-candidate-sources='{{ .Site.Params.menuRefresh.candidates | jsonify }}'>
                        <button type="button" class="force-refresh" title="Refresh Menu">&#x21bb;</button>
                    </div>

                    {{- range .Site.Menus.top }}
                        {{- partial "menu-item.html" (dict "Item" . "Page" $ "MenuName" "top" "Type" "dynamic") -}}
                    {{- end }}

                    {{- range .Site.Menus.main }}
                        {{- partial "menu-item.html" (dict "Item" . "Page" $ "MenuName" "main") -}}
                    {{- end }}
                </nav>
                <div class="nav-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
        </nav>
    </header>

    <main class="main-content">
        {{ block "main" . }}{{ end }}
    </main>

    <footer class="site-footer">
        <div class="footer-container">
            <p>&copy; {{ now.Year }} {{ .Site.Title }}. {{ .Site.Params.Description}}.</p>
            <div class="footer-links">
                {{- range .Site.Menus.footer -}}
                    <a href="{{ .URL }}" class="footer-link {{ if $.IsMenuCurrent "footer" . }}active{{ end }}">{{ .Name }}</a>
                {{- end -}}
            </div>

            <!-- Social icons (configured in site params -> social) -->
            <div class="footer-social">
                {{ partial "nav-social.html" . }}
            </div>
        </div>
    </footer>

    <!-- JavaScript -->
    <script src="{{ "js/main.js" | absURL }}"></script>
    <script src="{{ "js/base.js" | absURL }}"></script>

        <script>
        // Refresh nav menu: dynamic random menu items with caching and auto-refresh
        document.addEventListener('DOMContentLoaded', function(){
            const container = document.querySelector('.refresh-nav-menu');
            if(!container) {
                console.error('refresh-nav-menu container not found!');
                return;
            }

            const menuLength = parseInt(container.dataset.menuLength) || 4;
            const refreshIntervalMin = parseInt(container.dataset.refreshIntervalMin) || 5;

            const autoRefreshToggle = container.querySelector('.auto-refresh-toggle');
            const forceRefreshBtn = container.querySelector('.force-refresh');

            const menuContainer = document.querySelector('.nav-menu');
            if(!menuContainer) {
                console.error('nav-menu container not found!');
                return;
            }
            
            const candidates = []

            // Fetch additional candidates from configured sources if available
            const candidateConfig = container.dataset.candidateSources;
            if(candidateConfig){
                try {
                    const sources = JSON.parse(candidateConfig);
                    
                    // Fetch candidates from each configured source
                    const fetchPromises = [];
                    
                    for(const [key, mode] of Object.entries(sources)){
                        fetchPromises.push(
                            fetch(key + '/index.json')
                                .then(r => r.ok ? r.json() : null)
                                .then(data => {
                                    if(!data || !data.taxonomies) return;
                                    data.taxonomies.forEach(tax => {
                                        if(mode === 'self' || mode === 'both'){
                                            candidates.push({title: tax.title, url: tax.url});
                                        }
                                        if((mode === 'children' || mode === 'both') && tax.terms){
                                            tax.terms.forEach(term => {
                                                candidates.push({title: term.title, url: term.url});
                                            });
                                        }
                                    });
                                })
                                .catch(() => {})
                        );
                        
                    }
                    
                    // Wait for all fetches to complete before initializing
                    Promise.all(fetchPromises).finally(() => {
                        initMenu();
                    });
                } catch(e){
                    // If parsing fails, just use existing candidates
                    initMenu();
                }
            } else {
                // No additional sources configured
                initMenu();
            }

            const CACHE_KEY = 'refreshNavMenu_selected';
            const CACHE_TS_KEY = 'refreshNavMenu_timestamp';
            const AUTO_REFRESH_KEY = 'refreshNavMenu_autoRefresh';

            function initMenu(){
                function shuffle(arr){
                    const copy = arr.slice();
                    for(let i=copy.length-1; i>0; i--){
                        const j = Math.floor(Math.random()*(i+1));
                        [copy[i],copy[j]] = [copy[j],copy[i]];
                    }
                    return copy;
                }

                function pickRandom(count){
                    if(candidates.length === 0) return [];
                    const shuffled = shuffle(candidates);
                    return shuffled.slice(0, Math.min(count, shuffled.length));
                }

                function renderItems(items){
                    if(!items || items.length === 0){
                        return;
                    }

                    // Collect all menu items that follow the refresh-nav-menu container
                    // These are the dynamic menu items from .Site.Menus.top
                    const allMenuItems = Array.from(menuContainer.querySelectorAll('.nav-item'));

                    // Remove all current dynamic menu items
                    let firstNonDynamic = null;
                    allMenuItems.forEach(item => {
                        if(item.classList.contains('dynamic-item')) {
                            item.remove();
                        } else {
                            firstNonDynamic = firstNonDynamic || item;
                        }
                    });
                    
                    
                    // Show only the selected items
                    items.forEach((item, index) => {
                        if(item.url){
                            // This is a dynamically fetched item - create and insert it
                            const link = document.createElement('a');
                            link.href = item.url;
                            link.className = 'nav-item nav-link dynamic-item';
                            link.textContent = item.title;
                            
                            // Insert after the refresh button
                            menuContainer.insertBefore(link, firstNonDynamic);
                            
                        }
                    });
                }

                function getCached(){
                    try {
                        const cached = localStorage.getItem(CACHE_KEY);
                        const ts = localStorage.getItem(CACHE_TS_KEY);
                        if(!cached || !ts) return null;
                        const age = Date.now() - parseInt(ts);
                        const maxAge = refreshIntervalMin * 60 * 1000;
                        if(age > maxAge) return null;
                        return JSON.parse(cached);
                    } catch(e){ return null; }
                }

                function setCached(items){
                    try {
                        localStorage.setItem(CACHE_KEY, JSON.stringify(items));
                        localStorage.setItem(CACHE_TS_KEY, Date.now().toString());
                    } catch(e){}
                }

                function refreshMenu(force = false){
                    let items = force ? null : getCached();
                    if(!items){
                        items = pickRandom(menuLength);
                        setCached(items);
                    }
                    renderItems(items);
                }

                function startAutoRefresh(){
                    if(window.refreshNavInterval) clearInterval(window.refreshNavInterval);
                    window.refreshNavInterval = setInterval(()=>{
                        refreshMenu(true);
                    }, refreshIntervalMin * 60 * 1000);
                }

                function stopAutoRefresh(){
                    if(window.refreshNavInterval){
                        clearInterval(window.refreshNavInterval);
                        window.refreshNavInterval = null;
                    }
                }

                // Initialize auto-refresh toggle state from localStorage
                if(autoRefreshToggle){
                    const autoEnabled = localStorage.getItem(AUTO_REFRESH_KEY) === 'true';
                    autoRefreshToggle.checked = autoEnabled;
                    if(autoEnabled) startAutoRefresh();

                    autoRefreshToggle.addEventListener('change', function(){
                        const enabled = this.checked;
                        localStorage.setItem(AUTO_REFRESH_KEY, enabled.toString());
                        if(enabled){
                            startAutoRefresh();
                        } else {
                            stopAutoRefresh();
                        }
                    });
                }

                if(forceRefreshBtn){
                    forceRefreshBtn.addEventListener('click', function(){
                        refreshMenu(true);
                    });
                }
            }
        });
        </script>

        <script>
        // Mobile: expand/collapse submenu when tapping the parent menu item.
        (function(){
            const mq = window.matchMedia('(max-width: 768px)');

            function closeAllExcept(el){
                document.querySelectorAll('.nav-item.has-children.open').forEach(item=>{
                    if(item !== el){
                        item.classList.remove('open');
                        const l = item.querySelector(':scope > a.nav-link'); if(l) l.setAttribute('aria-expanded','false');
                    }
                });
            }

            function initMobileSubmenu(){
                document.querySelectorAll('.nav-item.has-children').forEach(item=>{
                    const link = item.querySelector(':scope > a.nav-link');
                    if(!link) return;
                    link.setAttribute('aria-haspopup','true');
                    link.setAttribute('aria-expanded', item.classList.contains('open') ? 'true' : 'false');

                    // Remove any previous handler to avoid double-binding when this script runs again
                    link.onclick = function(e){
                        if(mq.matches){
                            e.preventDefault();
                            const wasOpen = item.classList.contains('open');
                            if(!wasOpen){
                                closeAllExcept(item);
                                item.classList.add('open');
                                link.setAttribute('aria-expanded','true');
                            } else {
                                item.classList.remove('open');
                                link.setAttribute('aria-expanded','false');
                            }
                        }
                        // On desktop clicks behave normally (hover/links)
                    };
                });
            }

            document.addEventListener('DOMContentLoaded', initMobileSubmenu);

            // Close open submenus when switching to desktop sizes
            window.addEventListener('resize', function(){
                if(!mq.matches){
                    document.querySelectorAll('.nav-item.has-children.open').forEach(item=>{
                        item.classList.remove('open');
                        const l = item.querySelector(':scope > a.nav-link'); if(l) l.setAttribute('aria-expanded','false');
                    });
                }
            });

            // Close submenus when clicking outside nav on mobile
            document.addEventListener('click', function(e){
                if(!mq.matches) return;
                if(!e.target.closest('.nav-container')){
                    document.querySelectorAll('.nav-item.has-children.open').forEach(item=>{
                        item.classList.remove('open');
                        const l = item.querySelector(':scope > a.nav-link'); if(l) l.setAttribute('aria-expanded','false');
                    });
                }
            });
        })();
        </script>

</body>
</html>
